{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n#include <cmath>\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\nmotor LeftDriveSmart = motor(PORT1, 1, false);\nmotor RightDriveSmart = motor(PORT6, 1, true);\ngyro DrivetrainGyro = gyro(PORT2, true);\nsmartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, DrivetrainGyro, 200);\n\nmotor Door = motor(PORT4, false);\nmotor Arm = motor(PORT10, false);\nsonar DistanceSensorL = sonar(PORT12);\nsonar DistanceSensorR = sonar(PORT11);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double BrainTime = Brain.Timer.system() * 1000;\n  double BrainVoltage = Brain.Battery.voltage();\n  // Combine these values into a single integer\n  int seed = int(\n    BrainTime + BrainVoltage\n  );\n  // Set the seed\n  srand(seed); \n}\n\nbool vexcode_initial_drivetrain_calibration_completed = false;\nvoid calibrateDrivetrain() {\n  wait(200, msec);\n  Brain.Screen.print(\"Calibrating\");\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"Gyro\");\n  Brain.Screen.newLine();\n  DrivetrainGyro.calibrate();\n  while (DrivetrainGyro.isCalibrating()) {\n    wait(25, msec);\n  }\n  vexcode_initial_drivetrain_calibration_completed = true;\n  // Clears the screen and returns the cursor to row 1, column 1.\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n}\n\nvoid vexcodeInit() {\n\n  // Calibrate the Drivetrain\n  calibrateDrivetrain();\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n#define PI 3.14159265\n\n// Include the IQ Library\n#include \"vex.h\"\n\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n//Globals\n\n//Convert angle(fixed r) from polar to cartesian\n//index is theta, value is r*sin(theta), which is the x used in our equations\n//const float rsintheta[90]; May not need to save a little amount of time\n//From main:\n  //init rsintheta. It only goes through theta >= 0.break\n  //get theta < 0 by doing -value when you plug in sin(theta)\n  //for (int theta=0; theta<180; theta++) {\n    //float radians = (theta * PI) / 180.0f;\n    //rsintheta[theta] = std::sin(radians) * radius;}\n\nshort distancesL[90];\nshort distancesR[90];\n\nfloat radius = 1;\nfloat startx = .5;\n\n\nint min(int x, int y) {\n  return (x<y)?x:y;\n}\n\n\nint sign(int x) {\n  if (x > 0) {\n    return 1;\n  }\n  else if (x < 0) {\n    return -1;\n  }\n  return 0;\n}\n\n\nint arrayMin (short* array, int size) {\n  int minValue = 32767;\n\n  for(int i=0; i < size; i++) {\n    minValue = min(array[i], minValue);\n  }\n\n  return minValue;\n}\n\n\nvoid scanForDistances(int degreesRange) {\n  int dirFacing = Drivetrain.heading(degrees);\n  int halfDegrees = dirFacing/2;\n  \n  Drivetrain.turnToRotation(-halfDegrees, degrees);\n  for (int i=0; i<degreesRange; i++) {\n\n    distancesL[i] = DistanceSensorL.distance(mm);\n    distancesR[i] = DistanceSensorR.distance(mm);\n    Drivetrain.turnToRotation(1, degrees);\n  }\n\n  for(int i=degreesRange; i<90; i++) {\n    distancesL[i] = distancesL[0]; //So the unused values dont mess with distance\n    distancesR[i] = distancesR[0];\n  }\n\n  return;\n}\n\n\nshort hypToHeight(int hyp, float currentx, const float r, float startx) {\n  using namespace std;\n\n  auto circle = [](float x, float r) {\n    return sqrt((r*r - x*x));\n  };\n\n  float currenty = circle(currentx, r);\n  float oppDist = fabs(circle(startx, r) - currenty); //abs(starty - c(x))\n  float adjDist = fabs(startx - currentx);\n\n  float oppOverAdj = oppDist/adjDist; //From were the dist sensor started on the circle\n  //Helps us find the angle and extrapolate\n\n  float adjOverHyp = sqrt(1 + pow(oppOverAdj, 2));\n  float oppOverHyp = oppOverAdj / adjOverHyp; //equal to sin(arctan(x))\n\n  int distance = round((hyp * oppOverHyp) + currenty); //+b to get all equivalent relative to y=0\n  return distance;\n}\n\n\nvoid wander(int direction) {\n\n  //See in theres anything in the way\n  Drivetrain.turnToHeading(direction, degrees);\n  scanForDistances(90); //TODO change degrees to make sense\n  Drivetrain.turnToHeading(direction, degrees); //Turn back\n\n  //Convert the sensor distances into how far the robo can move\n  //This goes through the whole array\n  for (int i=0; i<90; i++){\n    //hypToHeight only gets H relative to y=0. We have to add a fixed amount to it\n    int hyp = distancesL[i];\n    float currentx = radius * sin(i);\n\n    distancesL[i] = hypToHeight(hyp, currentx, radius, startx);\n    }\n\n  //Im a lazy bum.\n  //And dont feel like passing C-arrays again. \n  //I just dont feel like it\n  for (int i=0; i<90; i++){\n    int hyp = distancesR[i];\n    float currentx = radius * sin(i);\n\n    distancesR[i] = hypToHeight(hyp, currentx, radius, startx);\n    }\n\n\n  //Get how far we can move\n  //two distance sensors may not be necessary\n  int minDistanceNeeded = 250; //in mm\n  int minDistanceL = arrayMin(distancesL, 90);\n  int minDistanceR = arrayMin(distancesR, 90);\n\n  int maxMoveLength = min(minDistanceL, minDistanceR);\n\n  if (maxMoveLength < minDistanceNeeded) {\n    return; //call it again with a differant direction(in wanderForever)\n  }\n\n  //Move as far as we can\n  Drivetrain.driveFor(forward, maxMoveLength - 50, mm); // len - 50 so we have some wiggle room(literally)\n}\n\n\nvoid wanderForever() {\n  int direction = 0;\n\n  while (true) {\n    wander(direction);\n\n\n    //Pick the next direction\n    int newDirection = rand() % 360;\n\n    //try not to pick the same direction again\n      int directionDiff = newDirection - direction;\n      if (abs(directionDiff) < 90) {\n        newDirection += 45*sign(directionDiff);\n        newDirection = newDirection % 360;\n      }\n\n      direction = newDirection;\n  }\n}\n\n\n// \"when started\" hat block\nvoid whenStarted() {\n  Brain.Screen.print(\"Wandering\");\n  Brain.Screen.newLine();\n  wanderForever();\n  return;\n}\n\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n\n  whenStarted();\n}","textLanguage":"cpp","robotConfig":[{"port":[1,6,2],"name":"Drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"200mm","gearRatio":"1:1","direction":"fwd","gyroType":"smart","width":"173","unit":"mm","wheelbase":"76","wheelbaseUnit":"mm","xOffset":"0","yOffset":"0","thetaOffset":"0"},"triportSourcePort":22},{"port":[4],"name":"Door","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[10],"name":"Arm","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"DistanceSensorL","customName":true,"deviceType":"Distance","deviceClass":"sonar","setting":{},"triportSourcePort":22},{"port":[11],"name":"DistanceSensorR","customName":true,"deviceType":"Distance","deviceClass":"sonar","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.64.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"target":"Physical"}